<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Seat Test - Realtime Booking</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .left-panel {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .right-panel {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }
        .connected { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
        .disconnected { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        
        /* Seat Layout Styles */
        .screen {
            background: #333;
            color: white;
            text-align: center;
            padding: 10px;
            margin: 20px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .seat-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 8px;
            max-width: 500px;
            margin: 20px auto;
        }
        .seat {
            width: 40px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
        }
        .seat.available {
            background: #e8f5e8;
            border-color: #28a745;
            color: #28a745;
        }
        .seat.available:hover {
            background: #d4edda;
            transform: scale(1.1);
        }
        .seat.selecting {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
            animation: pulse 1s infinite;
        }
        .seat.reserved {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
            cursor: not-allowed;
        }
        .seat.my-selection {
            background: #d1ecf1;
            border-color: #17a2b8;
            color: #0c5460;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .seat-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-seat {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid;
        }
        
        .messages {
            height: 250px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px 0;
            background: #f9f9f9;
            border-radius: 4px;
        }
        .message {
            margin: 5px 0;
            padding: 8px;
            border-left: 3px solid #007bff;
            background: white;
            border-radius: 4px;
            font-size: 12px;
        }
        button {
            padding: 10px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        input, select {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 150px;
        }
        .user-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .user-name {
            font-weight: bold;
            color: #495057;
        }
        .online-users {
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .user-badge {
            display: inline-block;
            background: #007bff;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin: 2px;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center; color: #333; margin-bottom: 30px;">üé¨ WebSocket Seat Booking Test - Realtime</h1>
    
    <div class="container">
        <!-- Left Panel: Seat Selection -->
        <div class="left-panel">
            <div class="user-info">
                <div class="user-name" id="userName">User: Guest</div>
                <div>Session: <span id="currentSession"></span></div>
            </div>

            <div id="status" class="status disconnected">
                üî¥ Status: Disconnected
            </div>

            <div style="margin: 15px 0;">
                <label>üë§ T√™n ng∆∞·ªùi d√πng:</label><br>
                <input type="text" id="userNameInput" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n" value="">
                
                <label>üé≠ Showtime ID:</label><br>
                <input type="number" id="showtimeId" value="1" min="1">
                
                <div style="margin-top: 10px;">
                    <button onclick="connect()" id="connectBtn">üîó K·∫øt n·ªëi</button>
                    <button onclick="disconnect()" id="disconnectBtn">‚ùå Ng·∫Øt k·∫øt n·ªëi</button>
                </div>
            </div>

            <!-- Online Users -->
            <div class="online-users">
                <strong>üë• Ng∆∞·ªùi d√πng ƒëang online:</strong>
                <div id="onlineUsers">Ch∆∞a k·∫øt n·ªëi</div>
            </div>

            <!-- Cinema Screen -->
            <div class="screen">üé¨ M√ÄN H√åNH CHI·∫æU</div>

            <!-- Seat Grid -->
            <div class="seat-grid" id="seatGrid">
                <!-- Seats will be generated by JavaScript -->
            </div>

            <!-- Seat Legend -->
            <div class="seat-legend">
                <div class="legend-item">
                    <div class="legend-seat available" style="background: #e8f5e8; border-color: #28a745;"></div>
                    <span>Tr·ªëng</span>
                </div>
                <div class="legend-item">
                    <div class="legend-seat selecting" style="background: #fff3cd; border-color: #ffc107;"></div>
                    <span>ƒêang ch·ªçn</span>
                </div>
                <div class="legend-item">
                    <div class="legend-seat my-selection" style="background: #d1ecf1; border-color: #17a2b8;"></div>
                    <span>T√¥i ƒë√£ ch·ªçn</span>
                </div>
                <div class="legend-item">
                    <div class="legend-seat reserved" style="background: #f8d7da; border-color: #dc3545;"></div>
                    <span>ƒê√£ ƒë·∫∑t</span>
                </div>
            </div>

            <!-- Selected Seats Info -->
            <div id="selectedSeats" style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                <strong>üé´ Gh·∫ø ƒë√£ ch·ªçn:</strong> <span id="selectedSeatsList">Ch∆∞a ch·ªçn gh·∫ø n√†o</span><br>
                <button onclick="confirmSelection()" id="confirmBtn" disabled>‚úÖ X√°c nh·∫≠n ƒë·∫∑t gh·∫ø</button>
                <button onclick="clearSelection()" id="clearBtn" disabled>üóëÔ∏è X√≥a l·ª±a ch·ªçn</button>
            </div>
        </div>

        <!-- Right Panel: Messages and Controls -->
        <div class="right-panel">
            <h3>üì® Tin nh·∫Øn WebSocket:</h3>
            <div id="messages" class="messages"></div>
            <div style="margin: 10px 0;">
                <button onclick="clearMessages()">üóëÔ∏è X√≥a tin nh·∫Øn</button>
                <button onclick="sendPing()">üì° Ping</button>
                <button onclick="refreshSeats()">üîÑ L√†m m·ªõi gh·∫ø</button>
            </div>

            <h3>üéÆ Thao t√°c nhanh:</h3>
            <div style="margin: 10px 0;">
                <label>Seat ID:</label>
                <input type="number" id="quickSeatId" value="1" min="1" max="50">
                <button onclick="quickReserve()">‚ö° ƒê·∫∑t nhanh</button>
                <button onclick="quickCancel()">‚ùå H·ªßy nhanh</button>
            </div>

            <h3>üìä Th·ªëng k√™:</h3>
            <div id="stats" style="background: #f8f9fa; padding: 10px; border-radius: 4px;">
                <div>T·ªïng gh·∫ø: <span id="totalSeats">50</span></div>
                <div>Gh·∫ø tr·ªëng: <span id="availableSeats">0</span></div>
                <div>Gh·∫ø ƒëang ch·ªçn: <span id="selectingSeats">0</span></div>
                <div>Gh·∫ø ƒë√£ ƒë·∫∑t: <span id="reservedSeats">0</span></div>
                <div>K·∫øt n·ªëi WebSocket: <span id="connectionCount">0</span></div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let sessionId = generateSessionId();
        let userName = '';
        let selectedSeats = new Set();
        let seatStates = {}; // Store seat states: available, selecting, reserved, my-selection
        let onlineUsers = new Set();
        let currentShowtimeId = 1;

        // Initialize
        document.getElementById('currentSession').textContent = sessionId;
        initializeSeatGrid();

        function generateSessionId() {
            return 'session_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        }

        function initializeSeatGrid() {
            const seatGrid = document.getElementById('seatGrid');
            seatGrid.innerHTML = '';
            
            // Create 50 seats (5 rows x 10 seats)
            for (let i = 1; i <= 50; i++) {
                const seat = document.createElement('div');
                seat.className = 'seat available';
                seat.id = `seat-${i}`;
                seat.textContent = i;
                seat.onclick = () => toggleSeatSelection(i);
                seatGrid.appendChild(seat);
                seatStates[i] = 'available';
            }
            updateStats();
        }

        function connect() {
            userName = document.getElementById('userNameInput').value.trim() || `User_${Math.random().toString(36).substr(2, 5)}`;
            currentShowtimeId = document.getElementById('showtimeId').value;
            
            document.getElementById('userName').textContent = `User: ${userName}`;
            
            if (ws) {
                ws.close();
            }

            const wsUrl = `ws://localhost:8000/api/v1/ws/seats/${currentShowtimeId}?session_id=${sessionId}`;
            addMessage(`üîó ƒêang k·∫øt n·ªëi t·ªõi: ${wsUrl}`, 'info');
            
            ws = new WebSocket(wsUrl);

            ws.onopen = function(event) {
                updateStatus(true);
                addMessage(`‚úÖ K·∫øt n·ªëi th√†nh c√¥ng! Ch√†o ${userName}`, 'success');
                
                // Send user info
                sendMessage({
                    type: 'user_joined',
                    user_name: userName,
                    session_id: sessionId
                });
            };

            ws.onclose = function(event) {
                updateStatus(false);
                addMessage(`‚ùå K·∫øt n·ªëi ƒë√£ ƒë√≥ng: ${event.code} - ${event.reason}`, 'warning');
                onlineUsers.clear();
                updateOnlineUsers();
            };

            ws.onerror = function(error) {
                addMessage(`üö® L·ªói WebSocket: ${error}`, 'error');
            };

            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                } catch (e) {
                    addMessage(`üì® Tin nh·∫Øn th√¥: ${event.data}`, 'received');
                }
            };
        }

        function handleWebSocketMessage(message) {
            addMessage(`üì® Nh·∫≠n: ${JSON.stringify(message, null, 2)}`, 'received');
            
            switch(message.type) {
                case 'initial_data':
                    handleInitialData(message.data);
                    break;
                case 'seat_update':
                    handleSeatUpdate(message.data);
                    break;
                case 'seats_reserved':
                    handleSeatsReserved(message.data);
                    break;
                case 'seats_released':
                    handleSeatsReleased(message.data);
                    break;
                case 'seat_selecting':
                    handleSeatSelecting(message.data);
                    break;
                case 'user_joined':
                    handleUserJoined(message.data);
                    break;
                case 'user_left':
                    handleUserLeft(message.data);
                    break;
                case 'seats_reserved_simulation':
                    handleSimulatedReservation(message);
                    break;
                case 'seats_released_simulation':
                    handleSimulatedCancellation(message);
                    break;
                case 'pong':
                    addMessage('üèì Pong nh·∫≠n ƒë∆∞·ª£c', 'info');
                    break;
                default:
                    addMessage(`‚ùì Lo·∫°i tin nh·∫Øn kh√¥ng x√°c ƒë·ªãnh: ${message.type}`, 'warning');
            }
        }

        function handleInitialData(data) {
            addMessage(`üé¨ ƒêang t·∫£i d·ªØ li·ªáu ban ƒë·∫ßu cho su·∫•t chi·∫øu ${currentShowtimeId}`, 'info');
            
            // Reset all seats to available
            for (let i = 1; i <= 50; i++) {
                seatStates[i] = 'available';
                updateSeatDisplay(i);
            }
            
            // Update reserved seats
            if (data.reserved_seats) {
                data.reserved_seats.forEach(seat => {
                    seatStates[seat.seat_id] = seat.session_id === sessionId ? 'my-selection' : 'reserved';
                    updateSeatDisplay(seat.seat_id);
                });
            }
            
            updateStats();
        }

        function handleSeatUpdate(data) {
            if (data.seat_id) {
                seatStates[data.seat_id] = data.status;
                updateSeatDisplay(data.seat_id);
                updateStats();
            }
        }

        function handleSeatsReserved(data) {
            if (data.seat_ids) {
                const isMyReservation = data.user_session === sessionId;
                data.seat_ids.forEach(seatId => {
                    seatStates[seatId] = isMyReservation ? 'my-selection' : 'reserved';
                    updateSeatDisplay(seatId);
                    
                    if (isMyReservation) {
                        selectedSeats.delete(seatId);
                    }
                });
                updateStats();
                updateSelectedSeats();
                
                if (!isMyReservation) {
                    addMessage(`üî¥ Gh·∫ø ${data.seat_ids.join(', ')} ƒë√£ ƒë∆∞·ª£c ng∆∞·ªùi kh√°c ƒë·∫∑t!`, 'warning');
                }
            }
        }

        function handleSeatsReleased(data) {
            if (data.seat_ids) {
                data.seat_ids.forEach(seatId => {
                    seatStates[seatId] = 'available';
                    updateSeatDisplay(seatId);
                });
                updateStats();
                addMessage(`üü¢ Gh·∫ø ${data.seat_ids.join(', ')} ƒë√£ ƒë∆∞·ª£c gi·∫£i ph√≥ng`, 'success');
            }
        }

        function handleSeatSelecting(data) {
            if (data.seat_ids && data.user_session !== sessionId) {
                data.seat_ids.forEach(seatId => {
                    if (seatStates[seatId] === 'available') {
                        seatStates[seatId] = 'selecting';
                        updateSeatDisplay(seatId);
                    }
                });
                updateStats();
                addMessage(`üü° C√≥ ng∆∞·ªùi ƒëang ch·ªçn gh·∫ø ${data.seat_ids.join(', ')}`, 'info');
            }
        }

        function handleUserJoined(data) {
            if (data.user_name && data.session_id !== sessionId) {
                onlineUsers.add(data.user_name);
                updateOnlineUsers();
                addMessage(`üëã ${data.user_name} ƒë√£ tham gia`, 'info');
            }
        }

        function handleUserLeft(data) {
            if (data.user_name) {
                onlineUsers.delete(data.user_name);
                updateOnlineUsers();
                addMessage(`üëã ${data.user_name} ƒë√£ r·ªùi ƒëi`, 'info');
            }
        }

        function handleSimulatedReservation(message) {
            if (message.seat_ids && message.user_session !== sessionId) {
                message.seat_ids.forEach(seatId => {
                    seatStates[seatId] = 'reserved';
                    updateSeatDisplay(seatId);
                });
                updateStats();
                addMessage(`üü† [M√î PH·ªéNG] ${message.user_name} ƒë√£ ƒë·∫∑t gh·∫ø: ${message.seat_ids.join(', ')}`, 'warning');
            }
        }

        function handleSimulatedCancellation(message) {
            if (message.seat_ids) {
                message.seat_ids.forEach(seatId => {
                    seatStates[seatId] = 'available';
                    updateSeatDisplay(seatId);
                });
                updateStats();
                addMessage(`üü¢ [M√î PH·ªéNG] ${message.user_name} ƒë√£ h·ªßy gh·∫ø: ${message.seat_ids.join(', ')}`, 'info');
            }
        }

        function disconnect() {
            if (ws) {
                // Send user leaving message
                sendMessage({
                    type: 'user_left',
                    user_name: userName,
                    session_id: sessionId
                });
                
                ws.close(1000, 'Manual disconnect');
                ws = null;
            }
            selectedSeats.clear();
            updateSelectedSeats();
        }

        function updateStatus(connected) {
            const statusEl = document.getElementById('status');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (connected) {
                statusEl.className = 'status connected';
                statusEl.textContent = 'üü¢ Status: ƒê√£ k·∫øt n·ªëi';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                statusEl.className = 'status disconnected';
                statusEl.textContent = 'üî¥ Status: Ch∆∞a k·∫øt n·ªëi';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }

        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                addMessage(`üì§ G·ª≠i: ${JSON.stringify(message, null, 2)}`, 'sent');
            } else {
                addMessage('‚ùå WebSocket ch∆∞a k·∫øt n·ªëi', 'error');
            }
        }

        function toggleSeatSelection(seatId) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('‚ùå Vui l√≤ng k·∫øt n·ªëi WebSocket tr∆∞·ªõc', 'error');
                return;
            }

            const currentState = seatStates[seatId];
            
            if (currentState === 'reserved') {
                addMessage(`‚ùå Gh·∫ø ${seatId} ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t!`, 'error');
                return;
            }
            
            if (currentState === 'selecting' && !selectedSeats.has(seatId)) {
                addMessage(`‚è≥ Gh·∫ø ${seatId} ƒëang ƒë∆∞·ª£c ng∆∞·ªùi kh√°c ch·ªçn!`, 'warning');
                return;
            }

            if (selectedSeats.has(seatId)) {
                // Deselect seat
                selectedSeats.delete(seatId);
                seatStates[seatId] = 'available';
                updateSeatDisplay(seatId);
                
                // Notify others that seat is no longer being selected
                sendMessage({
                    type: 'seat_deselected',
                    seat_id: seatId,
                    session_id: sessionId,
                    user_name: userName
                });
            } else {
                // Select seat
                selectedSeats.add(seatId);
                seatStates[seatId] = 'my-selection';
                updateSeatDisplay(seatId);
                
                // Notify others that seat is being selected
                sendMessage({
                    type: 'seat_selecting',
                    seat_id: seatId,
                    session_id: sessionId,
                    user_name: userName
                });
            }
            
            updateSelectedSeats();
            updateStats();
        }

        function updateSeatDisplay(seatId) {
            const seatElement = document.getElementById(`seat-${seatId}`);
            if (seatElement) {
                seatElement.className = `seat ${seatStates[seatId]}`;
            }
        }

        function updateSelectedSeats() {
            const selectedList = document.getElementById('selectedSeatsList');
            const confirmBtn = document.getElementById('confirmBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            if (selectedSeats.size > 0) {
                const seatNumbers = Array.from(selectedSeats).sort((a, b) => a - b);
                selectedList.textContent = seatNumbers.join(', ');
                confirmBtn.disabled = false;
                clearBtn.disabled = false;
            } else {
                selectedList.textContent = 'Ch∆∞a ch·ªçn gh·∫ø n√†o';
                confirmBtn.disabled = true;
                clearBtn.disabled = true;
            }
        }

        function updateStats() {
            const available = Object.values(seatStates).filter(state => state === 'available').length;
            const selecting = Object.values(seatStates).filter(state => state === 'selecting').length;
            const reserved = Object.values(seatStates).filter(state => state === 'reserved' || state === 'my-selection').length;
            
            document.getElementById('availableSeats').textContent = available;
            document.getElementById('selectingSeats').textContent = selecting;
            document.getElementById('reservedSeats').textContent = reserved;
        }

        function updateOnlineUsers() {
            const onlineUsersDiv = document.getElementById('onlineUsers');
            if (onlineUsers.size === 0) {
                onlineUsersDiv.innerHTML = 'Ch·ªâ c√≥ b·∫°n';
            } else {
                const userBadges = Array.from(onlineUsers).map(user => 
                    `<span class="user-badge">${user}</span>`
                ).join('');
                onlineUsersDiv.innerHTML = userBadges;
            }
        }

        function confirmSelection() {
            if (selectedSeats.size === 0) {
                addMessage('‚ùå Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt gh·∫ø', 'error');
                return;
            }
            
            const seatIds = Array.from(selectedSeats);
            addMessage(`üé´ ƒêang x√°c nh·∫≠n ƒë·∫∑t gh·∫ø: ${seatIds.join(', ')}...`, 'info');
            
            // Simulate reservation via WebSocket if CORS fails
            const reservationData = seatIds.map(seatId => ({
                seat_id: parseInt(seatId),
                showtime_id: parseInt(currentShowtimeId),
                session_id: sessionId,
                status: 'pending'
            }));
            
            // Try API first, fallback to WebSocket simulation
            fetch('http://localhost:8000/api/v1/reservations/multiple', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Request-Method': 'POST',
                    'Access-Control-Request-Headers': 'Content-Type',
                },
                body: JSON.stringify(reservationData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success || data.status === 'success') {
                    addMessage(`‚úÖ ƒê·∫∑t gh·∫ø th√†nh c√¥ng qua API: ${JSON.stringify(data, null, 2)}`, 'success');
                } else {
                    addMessage(`‚ùå L·ªói ƒë·∫∑t gh·∫ø: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            })
            .catch(error => {
                addMessage(`‚ö†Ô∏è API kh√¥ng kh·∫£ d·ª•ng (CORS): ${error.message}`, 'warning');
                addMessage(`üîÑ Chuy·ªÉn sang m√¥ ph·ªèng qua WebSocket...`, 'info');
                
                // Fallback: Simulate via WebSocket
                simulateReservation(seatIds);
            });
        }

        function clearSelection() {
            Array.from(selectedSeats).forEach(seatId => {
                seatStates[seatId] = 'available';
                updateSeatDisplay(seatId);
                
                // Notify others
                sendMessage({
                    type: 'seat_deselected',
                    seat_id: seatId,
                    session_id: sessionId,
                    user_name: userName
                });
            });
            
            selectedSeats.clear();
            updateSelectedSeats();
            updateStats();
        }

        function quickReserve() {
            const seatId = parseInt(document.getElementById('quickSeatId').value);
            if (seatStates[seatId] !== 'available') {
                addMessage(`‚ùå Gh·∫ø ${seatId} kh√¥ng kh·∫£ d·ª•ng`, 'error');
                return;
            }
            
            addMessage(`‚ö° ƒê·∫∑t nhanh gh·∫ø ${seatId}...`, 'info');
            
            fetch('http://localhost:8000/api/v1/reservations/multiple', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify([{
                    seat_id: seatId,
                    showtime_id: parseInt(currentShowtimeId),
                    session_id: sessionId,
                    status: 'pending'
                }])
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                addMessage(`‚ö° K·∫øt qu·∫£ ƒë·∫∑t nhanh API: ${JSON.stringify(data, null, 2)}`, 'success');
            })
            .catch(error => {
                addMessage(`‚ö†Ô∏è API ƒë·∫∑t nhanh l·ªói CORS: ${error.message}`, 'warning');
                addMessage(`üîÑ M√¥ ph·ªèng ƒë·∫∑t gh·∫ø ${seatId}...`, 'info');
                simulateReservation([seatId]);
            });
        }

        function quickCancel() {
            const seatId = parseInt(document.getElementById('quickSeatId').value);
            
            addMessage(`‚ùå H·ªßy nhanh gh·∫ø ${seatId}...`, 'info');
            
            fetch(`http://localhost:8000/api/v1/reservations/${currentShowtimeId}?seat_ids=${seatId}&session_id=${sessionId}`, {
                method: 'DELETE',
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                addMessage(`‚ùå K·∫øt qu·∫£ h·ªßy nhanh API: ${JSON.stringify(data, null, 2)}`, 'success');
            })
            .catch(error => {
                addMessage(`‚ö†Ô∏è API h·ªßy nhanh l·ªói CORS: ${error.message}`, 'warning');
                addMessage(`üîÑ M√¥ ph·ªèng h·ªßy gh·∫ø ${seatId}...`, 'info');
                simulateCancellation([seatId]);
            });
        }

        function refreshSeats() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('‚ùå WebSocket ch∆∞a k·∫øt n·ªëi', 'error');
                return;
            }
            
            addMessage('üîÑ L√†m m·ªõi d·ªØ li·ªáu gh·∫ø...', 'info');
            sendMessage({ type: 'refresh_seats' });
        }

        function sendPing() {
            sendMessage({ type: 'ping' });
        }

        function addMessage(text, type) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `<strong>[${timestamp}]</strong> ${text}`;
            
            // Color coding
            switch(type) {
                case 'success':
                    messageDiv.style.borderLeftColor = '#28a745';
                    messageDiv.style.background = '#d4edda';
                    break;
                case 'error':
                    messageDiv.style.borderLeftColor = '#dc3545';
                    messageDiv.style.background = '#f8d7da';
                    break;
                case 'warning':
                    messageDiv.style.borderLeftColor = '#ffc107';
                    messageDiv.style.background = '#fff3cd';
                    break;
                case 'info':
                    messageDiv.style.borderLeftColor = '#17a2b8';
                    messageDiv.style.background = '#d1ecf1';
                    break;
                case 'sent':
                    messageDiv.style.borderLeftColor = '#6f42c1';
                    messageDiv.style.background = '#e2e3f3';
                    break;
                case 'received':
                    messageDiv.style.borderLeftColor = '#20c997';
                    messageDiv.style.background = '#d1f2eb';
                    break;
                default:
                    messageDiv.style.borderLeftColor = '#6c757d';
                    break;
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Auto-clear old messages (keep only last 50)
            while (messagesDiv.children.length > 50) {
                messagesDiv.removeChild(messagesDiv.firstChild);
            }
        }

        function clearMessages() {
            document.getElementById('messages').innerHTML = '';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            addMessage('üé¨ ·ª®ng d·ª•ng test WebSocket ƒë√£ s·∫µn s√†ng!', 'info');
            addMessage('üë§ Nh·∫≠p t√™n v√† nh·∫•n "K·∫øt n·ªëi" ƒë·ªÉ b·∫Øt ƒë·∫ßu', 'info');
            addMessage('‚ö†Ô∏è L∆∞u √Ω: N·∫øu g·∫∑p l·ªói CORS, ·ª©ng d·ª•ng s·∫Ω t·ª± ƒë·ªông chuy·ªÉn sang ch·∫ø ƒë·ªô m√¥ ph·ªèng', 'warning');
            addMessage('üîß ƒê·ªÉ s·ª≠ d·ª•ng API th·∫≠t, h√£y kh·ªüi ƒë·ªông backend server tr∆∞·ªõc', 'info');
            updateStatus(false);
        });

        // Simulation functions for when API is not available
        function simulateReservation(seatIds) {
            // Mark seats as reserved locally
            seatIds.forEach(seatId => {
                seatStates[seatId] = 'my-selection';
                updateSeatDisplay(seatId);
                selectedSeats.delete(seatId);
            });
            
            // Send WebSocket notification to simulate backend behavior
            sendMessage({
                type: 'seats_reserved_simulation',
                seat_ids: seatIds,
                user_session: sessionId,
                user_name: userName,
                timestamp: new Date().toISOString()
            });
            
            updateSelectedSeats();
            updateStats();
            addMessage(`‚úÖ [M√î PH·ªéNG] ƒê√£ ƒë·∫∑t gh·∫ø: ${seatIds.join(', ')}`, 'success');
        }
        
        function simulateCancellation(seatIds) {
            // Mark seats as available locally
            seatIds.forEach(seatId => {
                seatStates[seatId] = 'available';
                updateSeatDisplay(seatId);
            });
            
            // Send WebSocket notification
            sendMessage({
                type: 'seats_released_simulation',
                seat_ids: seatIds,
                user_session: sessionId,
                user_name: userName,
                timestamp: new Date().toISOString()
            });
            
            updateStats();
            addMessage(`‚úÖ [M√î PH·ªéNG] ƒê√£ h·ªßy gh·∫ø: ${seatIds.join(', ')}`, 'success');
        }

        // Auto-refresh connection count every 30 seconds
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                fetch(`http://localhost:8000/api/v1/ws/status/${currentShowtimeId}`)
                    .then(response => {
                        if (!response.ok) throw new Error('API not available');
                        return response.json();
                    })
                    .then(data => {
                        document.getElementById('connectionCount').textContent = data.active_connections || 0;
                    })
                    .catch(() => {
                        document.getElementById('connectionCount').textContent = 'API N/A';
                    });
            } else {
                document.getElementById('connectionCount').textContent = '0';
            }
        }, 30000);

        // Handle page unload - disconnect gracefully
        window.addEventListener('beforeunload', function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                sendMessage({
                    type: 'user_left',
                    user_name: userName,
                    session_id: sessionId
                });
                ws.close();
            }
        });
    </script>
</body>
</html>